---
title: "Staypoint estimation"
output:
  workflowr::wflow_html
---

# Staypoint estimation

We are trying determine what is the set of GPS points that participate in a staypoint

## preliminary data cleaning
1) eliminate duplicates - many duplicate locations at a time stamp. Keep most accurate location at a time stamp
2) many locations at north pole, markedly wrong.  Eliminate them.
3) calculate interval and distance between timestamps

## Determine staypoints

The staypoint determination algorithm uses 4 variables;
 - min_staypoint_time  - minimum time, in minutes, that must stay within max_staypoint_distance
 * max_jump_time - maximum time, in minutes, between readings
 * max_staypoint_distance - maximum distance for readings to be counted as a single staypoint
 * sigma - smoothing parameter.  Smaller is more smooth


```{r results='hide', message=FALSE, warning=FALSE}
options(warn=-1)
library( knitr )
opts_chunk$set(cache=TRUE, autodep=TRUE)

source('lib/functions.R')
source('lib/get_data.R')
source('lib/location_prep.R')
library(tidyverse)
library(lubridate)

# load in the individual locations information
df_location = get_df_location()

# load in the best guess location information
df_best_location = get_df_best_location( df_location )

```

```{r process_one_set, eval=TRUE}


#debug( do_one_search)
#undebug( do_one_search)

do_one_search = function( .df ) {
  dput(.df)
  cat("\n")

  fname  = glue( "data/save_v1_{.df$i_min_staypoint_time}_{.df$i_max_jump_time}_{.df$i_max_staypoint_distance}_{.df$i_sigma}_df.rds")

  df_location %>%  
    group_by( userid, night ) %>%
    arrange( timestamp ) %>%
    group_modify( ~prune_gps_outliers(.x, sigma = sigma)) %>%
    group_modify( ~findStayPoint(.x,  .df$i_max_jump_time, .df$i_min_staypoint_time, .df$i_max_staypoint_distance)) %>%
    select( local_time, timestamp, n_staypoint, duration, distance, everything()) %>% 
    { . } -> df

    saveRDS(df,  file=fname)

  data.frame(1)
}


```


# generate a subset of staypoints for a single parameter set


```{r test_with_subset,eval=FALSE }

df_location %>% 
  #filter(userid=='f181ac9f-f678-40ce-89ea-7d5c807e3b68' & night == '2014-10-18') %>%
  filter( userid=='05f35693-7fec-4372-af78-7bd904c187e0' & night=='2014-10-10'  ) %>% 
  arrange( userid, night, timestamp ) %>%
  { . } -> b


min_staypoint_time=10*60
max_jump_time=20*60
max_staypoint_distance=200
sigma=.5

list(
i_min_staypoint_time=min_staypoint_time,
i_max_jump_time=max_jump_time,
i_max_staypoint_distance=max_staypoint_distance,
i_sigma=sigma
     ) %>% as.tibble() %>% 
     { . } -> df

do_one_search( df )

  df_location %>%  
    group_by( userid, night ) %>%
    arrange( timestamp ) %>%
    group_modify( ~prune_gps_outliers(.x, sigma = sigma)) %>%
    group_modify( ~findStayPoint(.x,  max_jump_time, min_staypoint_time, max_staypoint_distance)) %>%
    select( local_time, timestamp, n_staypoint, duration, distance, everything()) %>% 
    { . } -> b1_m

b1_m %>% count( n_staypoint )


```



```{r explore_subset, eval=FALSE}

df_best_location %>% distinct( userid, night )

df_best_location %>% 
  filter( is.na( interval ))

```


```{r good_path_visualisation,eval=FALSE }

sigma=30*1000/3600
b %>% 
select( interval, dist, speed, accuracy, everything())  %>% 
  filter( speed <=sigma  ) %>%
ggplot(aes( latitude, longitude, color=timestamp, size=speed)) + 
geom_point( ) + 
geom_path()

```

# generate a range of staypoint estimates, for a range of parameters


```{r generate_staypoints, eval=TRUE }

min_staypoint_time_range=c(5,10, 15)*60
max_jump_time_range=c(2,5)*60
max_staypoint_distance_range= c(5,10,20)
sigma_range=c(.25, .5, 1)

expand.grid(min_staypoint_time_range,max_jump_time_range,max_staypoint_distance_range, sigma_range ) %>% 
  setNames( qc(i_min_staypoint_time, i_max_jump_time, i_max_staypoint_distance, i_sigma )) %>%
  as.tibble() %>% 
  { . } -> grid_search 
  



library(multidplyr)
library(parallel)
cl <- detectCores()
cluster <- create_cluster(cores = cl)

#debug(findStayPoint)
#debug(do_one_search )

#undebug(findStayPoint)
#undebug(do_one_search )

#options(error = recover) # setting the error option
#options(error = traceback) # setting the error option
#options(show.error.locations = TRUE)

grid_search %>%
  mutate( row_num=row_number()) %>%
  partition(row_num, cluster = cluster) %>%
  cluster_library("glue") %>%
  cluster_library("geosphere") %>%
  cluster_library("tidyverse") %>%
  cluster_copy( df_best_location ) %>%
  cluster_copy( distanceBetween) %>%
  cluster_copy( findStayPoint) %>%
  cluster_copy( do_one_search) %>%
  cluster_copy( distance2centroid ) %>%
  do( do_one_search( .) ) %>%
  collect() %>% 
  { . } -> grid_output

```
